/** @mainpage MODBUS-CPP

MODBUS-CPP library is a modern C++ library for communicating with Modbus devices
by TCP/IP. It is designed to be simple to use, typesafe and to have great performance.

@section mainpage-feature Features

-   Support of common function codes:
    -   @cpp 0x03 @ce Read Holding Registers
    -   @cpp 0x04 @ce Read Input Registers
    -   @cpp 0x06 @ce Write Single Register
    -   @cpp 0x10 @ce Write Multiple Registers
-   Support for all exception codes
-   Automatic scheduling of register polls
-   Asynchronous request handling by worker threads using <a href="https://github.com/chriskohlhoff/asio">asio</a>
-   Logging using <a href="https://github.com/gabime/spdlog">spdlog</a>

@section mainpage-build Building

The following dependencies are needed to build the library:
-   A modern C++ compiler fully supporting C++14 standard.
    This library is continously tested with GCC 6.4.0 and LLVM/Clang 5.0.0.
    It is also regularly built using Microsoft Visual Studio 2017.
-   <a href="https://cmake.org/">CMake 3.8+</a>
-   A git client supporting submodules (1.5.3+)

To build the library, follow these steps:
-   Clone the repository recursively with `git clone https://github.com/aegis4ics/modbus-cpp.git --recursive`
-   Create a `build` directory inside the project.
-   Inside the build directory, configure the project using `cmake ..` or the interactive `ccmake ..`
    The default options should work out of the box.
-   Build the project with `cmake --build .`

@subsection mainpage-building-cmake CMake usage

The following CMake cache variables can be tuned to control the building of the library:
-   `MODBUS_BUILD_TESTS`: Set to `ON` to build the unit tests and the performance tests should be built.
    These tests will appear as `modbus_tests` and `modbus_perf_tests` targets respectively.
-   `MODBUS_BUILD_EXAMPLE`: Set to `ON` to build the example application. The example will appear as
    `modbus_example` target.

By default, these variables will be set to `ON` when building only this library, and to `OFF` if
the project is added with `add_subdirectory`.

To use this library in a project, it is recommend to simply add this repository as a submodule, then
add this project in CMake with `add_subdirectory`. Then, the target `modbus-cpp` will be available to link with.
For example, `foo` project can use MODBUS-CPP by doing this in its `CMakeLists.txt`.

@code{.cmake}
add_subdirectory(./modbus-cpp)
add_executable(foo PRIVATE modbus-cpp)
@endcode

@section mainpage-usage Usage

To learn how to use the library, it is recommended to have a look at the example project, available
<a href="https://github.com/aegis4ics/modbus-cpp/blob/master/example/main.cpp">here</a>. It makes use of all
the functionalities of the library.

After reading the example and playing with it, a quick scan trough the documentation can help
gain understanding of the library. It is recommended to start with the @ref modbus::IModbusManager class
documentation, since it represents the main entrypoint of the library. The reader can proceed with
@ref modbus::IChannel and @ref modbus::ISession to learn how to create a session with a Modbus device and
send requests to it.

@subsection mainpage-usage-threading-model Note about the threading model

This library uses a pool of background threads created by @ref modbus::IModbusManager to execute the
asynchronous operations. All the public API's methods are thread-safe. However, client code must
be cautious in the response handlers.

@warning All the response handlers are called from background threads created by the @ref modbus::IModbusManager.
Therefore, all response handlers *should not block* in any way. Otherwise, you risk having other channels
not performing their tasks because the thread is blocked or even deadlocks. Also, be sure to use the
appropriate mechanisms to eliminate the risks of race conditions in the user code. See @ref modbus::IModbusManager
and @ref modbus::ResponseHandler for more details.

@subsection mainpage-usage-resource-releasing Resource releasing

Because of the asynchronous model used in this library, resource releasing may seem odd to certain users.
@ref modbus::IModbusManager, @ref modbus::IChannel and @ref modbus::ISession usually returns
@cpp std::shared_ptr @ce. These shared pointers are always owned by the parent that created it. For
example, @ref modbus::IModbusManager owns all the @ref modbus::IChannel pointers it has created. Therefore,
even if the client code releases all the pointer, the channel will stay alive until
@ref modbus::IModbusManager::shutdown() is called (or its destructor).

It is guaranteed that when @ref modbus::IModbusManager shuts down, all the associated resources will
be *gracefully* shutdown and disposed, and all the background threads will be joined appropriately.
Once again, it is important that all the response handlers must *not* block. Otherwise, the shutdown
sequence may generate a deadlock.

*/
